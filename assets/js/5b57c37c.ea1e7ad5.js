"use strict";(self.webpackChunkanthology_dev_docs=self.webpackChunkanthology_dev_docs||[]).push([[546],{4137:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>g});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},m=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=l(t),d=r,g=u["".concat(c,".").concat(d)]||u[d]||p[d]||o;return t?a.createElement(g,s(s({ref:n},m),{},{components:t})):a.createElement(g,s({ref:n},m))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=d;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5730:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=t(7462),r=(t(7294),t(4137));const o={},s="Messaging Recommendations",i={unversionedId:"REST APIs/Premium APIs/UEF/UEF Documentation/MessagingRecommendations",id:"REST APIs/Premium APIs/UEF/UEF Documentation/MessagingRecommendations",title:"Messaging Recommendations",description:"Table of Contents",source:"@site/docs/REST APIs/Premium APIs/UEF/UEF Documentation/MessagingRecommendations.md",sourceDirName:"REST APIs/Premium APIs/UEF/UEF Documentation",slug:"/REST APIs/Premium APIs/UEF/UEF Documentation/MessagingRecommendations",permalink:"/docs/REST APIs/Premium APIs/UEF/UEF Documentation/MessagingRecommendations",draft:!1,tags:[],version:"current",frontMatter:{}},c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Iframe to Iframe communication",id:"iframe-to-iframe-communication",level:2},{value:"LocalStorage",id:"localstorage",level:3},{value:"HTTP",id:"http",level:3},{value:"Recommendation",id:"recommendation",level:3},{value:"Static content to iframe communication",id:"static-content-to-iframe-communication",level:2}],m={toc:l},u="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"messaging-recommendations"},"Messaging Recommendations"),(0,r.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#iframe-to-iframe-communication"},"Iframe to Iframe communication"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#localstorage"},"LocalStorage")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#http"},"HTTP")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#recommendation"},"Recommendation")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#static-content-to-iframe-communication"},"Static Content to Iframe communication"))),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"In some cases, an Integration may want to render content into Ultra\nand have that content send messages back to the originating integration.\nThere are two primary use cases for this"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"iframe to iframe"),(0,r.kt)("li",{parentName:"ol"},"static content to Iframe.")),(0,r.kt)("p",null,"In the case of iframe to iframe the goal is to send content from a portal\nthat is an iframe back to the originating iframe (integration loaded in ultra).\nIn the case of static content the goal is to send events from statically rendered content back\nto the originating iframe."),(0,r.kt)("h2",{id:"iframe-to-iframe-communication"},"Iframe to Iframe communication"),(0,r.kt)("p",null,"In the case of Iframe to Iframe communication we have a bit more control of sending messages between contexts.\nCurrently there are two known ways to do this. This can be accomplished by using either LocalStorage or HTTP."),(0,r.kt)("h3",{id:"localstorage"},"LocalStorage"),(0,r.kt)("p",null,"The first is to use ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"},"LocalStorage"),"\nas a message bus between the two iframes."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"LIMITATION WARNING: In order for this to work both iframes have to have the same origin. If this is not the case then this will not work.")),(0,r.kt)("p",null,"The implementation for this is rather easy and can be broken down into the following"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// localStorageMessager.js (used in all following scripts.)\nconst subscribers = new Map();\n\nconst updateSubscribers = (subs, data) => {\n    subs.forEach(sub => {\n        sub(data);\n    });\n}\n\nwindow.addEventListener('storage', (event) => {\n    const subs = subscribers.get(event.key); // Get subscribers.\n\n    if (!subs) {\n        return;\n    }\n\n    updateSubscribers(subs, JSON.parse(event.newValue)); // Notify subscribers.\n});\n\nconst subscribe = (topic, callback) => {\n    const current = subscribers.get(topic);\n\n    if (current) {\n        current.push(callback);\n    } else {\n        subscribers.set(topic, [callback]);\n    }\n};\n\nconst publish = (topic, value) => {\n    localStorage.setItem(topic, JSON.stringify(value));\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// iframe rendered content\nsubscribe('topic.response', event => {\n    console.log('Got message from owning integration ', event);\n});\npublish('topic.send', {data: 'hello'});\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// owning integration\nsubscribe('topic.send', event => {\n    console.log('Got message from rendered content ', event);\n    publish('topic.response', {data: 'Greetings'});\n});\n")),(0,r.kt)("h3",{id:"http"},"HTTP"),(0,r.kt)("p",null,"Another more complicated approach would be to use fetch\nor XMLHttpRequest to send a message from the iframe to a web service.\nThis web service would in turn forward the message on to the originating iframe.\nWhile this approach is a bit more difficult,\nif done correctly this can allow cross origin communication."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// httpManager.js (used in all scripts but server script.)\nconst subscribers = new Map();\n\nconst updateSubscribers = (subs, data) => {\n    subs.forEach(sub => {\n        sub(data);\n    });\n}\n\nconst evtSource = new EventSource(`/api/messaging`); // Create an EventSource to get data back gradually over time.\nevtSource.addEventListener('message', (event) => {\n    const res = JSON.parse(event.data);\n\n    res.forEach(message => {\n        const subs = subscribers.get(message.topic);\n\n        if (subs) {\n            updateSubscribers(subs, message.value);\n        }\n    });\n});\n\nevtSource.addEventListener('open', () => {\n    console.log('Message channel is open');\n});\n\nconst subscribe = (topic, callback) => {\n    const current = subscribers.get(topic);\n\n    if (current) {\n        current.push(callback);\n    } else {\n        subscribers.set(topic, [callback]);\n    }\n};\n\nconst publish = (topic, value) => {\n    const message = new Request('http://mysite.com/api/messaging/data', {\n        method: 'POST',\n        body: JSON.stringify({ topic, value}),\n        headers: new Headers([\n            ['Content-Type', 'application/json;charset=UTF-8']\n        ])\n    });\n\n    fetch(message); // Send the message to the web server.\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// web server handler (in express)\nconst messages = new Map();\nconst listeners = [];\n\nconst registerMessagingHandlers = (app) => { // Call this with your express app\n    function formatMessage(message) {\n        return `data: ${JSON.stringify(message)}\\n\\n`; // Correct the format for event stream.\n    }\n\n    function updateListeners() {\n        const retVal = [];\n\n        messages.forEach((v, k) => {\n            retVal.push({\n                topic: k,\n                value: v,\n            });\n        });\n\n        listeners.forEach((v) => {\n            v.write(formatMessage(retVal));\n        });\n    }\n\n    app.post('/api/messaging/data', (req, res) => {\n        const current = messages.get(req.body.topic);\n        if (current === req.body.value) {\n            return;\n        }\n\n        messages.set(req.body.topic, req.body.value);\n\n        setTimeout(() => {\n            updateListeners(); // Send new data to clients\n        });\n\n        res.status(201).send();\n    });\n\n    app.get('/api/messaging', (req, res) => { // Handle incoming event source request.\n        listeners.push(res);\n        const retVal = [];\n\n        messages.forEach((v, k) => {\n            retVal.push({\n                topic: k,\n                value: v,\n            });\n        });\n\n        res.writeHead(200, {\n            'Cache-Control': 'no-cache',\n            'Connection': 'keep-alive',\n            'Content-Type': 'text/event-stream',\n        });\n\n        res.write(formatMessage(retVal)); // Send current state.\n    });\n};\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// iframe rendered content\nsubscribe('topic.response', event => {\n    console.log('Got message from owning integration ', event);\n});\npublish('topic.send', {data: 'hello'});\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// owning integration\nsubscribe('topic.send', event => {\n    console.log('Got message from rendered content ', event);\n    publish('topic.response', {data: 'Greetings'});\n});\n")),(0,r.kt)("h3",{id:"recommendation"},"Recommendation"),(0,r.kt)("p",null,"For most cases the LocalStorage approach would be our recommendation.\nThe LocalStorage approach is the easiest to implement and has been proven more times."),(0,r.kt)("h2",{id:"static-content-to-iframe-communication"},"Static content to iframe communication"),(0,r.kt)("p",null,"In some cases an integration might want to render interactive content without the use of iframes.\nIn this case the integration can use callbacks.\nCallbacks will notify the integrations iframe when a change has occured.\nIn the below example we use callbacks to create a simple counter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const btnStyle = {\n    'margin': '4px'\n};\n\nlet count = 0;\nlet renderId;\n\nfunction renderContent() {\n    let contents = {\n      tag: 'span',\n      children: [\n        {\n          tag: 'button',\n          props: {\n            onClick: {\n              callbackId: '1', // Id to be sent when button is pressed.\n              mode: 'sync'\n            },\n            style: btnStyle\n          },\n          children: 'Decrement'\n        },\n        {\n          tag: 'span',\n          props: {},\n          children: `Current Value ${count}`\n        },\n        {\n          tag: 'button',\n          props: {\n            onClick: {\n              callbackId: '2', // Id to be sent when button is pressed.\n              mode: 'sync'\n            },\n            style: btnStyle\n          },\n          children: 'Increment'\n        }\n      ]\n    };\n\n    sendMessage({\n      type: \"portal:render\",\n      portalId: renderId,\n      contents: contents\n    });\n}\n\nconst onUltraMessageReceived = (msg) => {\n  if (msg.data.type === 'authorization:authorize') {\n    ultraMessageChannel.postMessage({\n      \"type\": \"event:subscribe\",\n      \"subscriptions\": ['click', 'hover', 'route', 'portal:new', 'portal:removed']\n    });\n\n    ultraMessageChannel.postMessage({\n      \"type\": \"portal:panel\",\n      \"correlationId\": \"some:id\",\n      \"panelType\": \"small\",\n      \"panelTitle\": \"Static Messaging\"\n    }); // Create panel when authorization is done.\n  }\n\n  if (msg.data.type === \"event:event\") {\n      switch (msg.data.eventType) {\n        case \"portal:new\":\n          renderId = msg.data.portalId;\n          renderContent(); // Portal has been created render initial content.\n          break;\n      }\n  }\n\n  if (msg.data.type === \"portal:callback\") { // Got a callback update our state\n      if (msg.data.callbackId === \"1\" && count > 0) {\n          count--; // Decrement button was pressed.\n      } else if (msg.data.callbackId === \"2\") {\n          count++; // Increment button was pressed.\n      }\n\n      renderContent();\n  }\n};\n\ninit(onUltraMessageReceived);\n\n")))}p.isMDXComponent=!0}}]);