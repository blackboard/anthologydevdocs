"use strict";(self.webpackChunkanthology_dev_docs=self.webpackChunkanthology_dev_docs||[]).push([[4782],{4137:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=s(n),h=o,g=u["".concat(c,".").concat(h)]||u[h]||p[h]||i;return n?r.createElement(g,a(a({ref:t},d),{},{components:n})):r.createElement(g,a({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[u]="string"==typeof e?e:o,a[1]=l;for(var s=2;s<i;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7571:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var r=n(7462),o=(n(7294),n(4137));const i={layout:"post",title:"Handling OIDC Login",id:"handling-oidc-login",categories:"Standards",published:"",edited:"",author:"Eric Preston"},a=void 0,l={unversionedId:"lti/core/handling-oidc-login",id:"lti/core/handling-oidc-login",title:"Handling OIDC Login",description:"Overview",source:"@site/docs/lti/core/oidc-login.md",sourceDirName:"lti/core",slug:"/lti/core/handling-oidc-login",permalink:"/docs/lti/core/handling-oidc-login",draft:!1,tags:[],version:"current",frontMatter:{layout:"post",title:"Handling OIDC Login",id:"handling-oidc-login",categories:"Standards",published:"",edited:"",author:"Eric Preston"},sidebar:"documentationSidebar",previous:{title:"Handling the Launch with id_token JWT",permalink:"/docs/lti/core/id-token"},next:{title:"OIDC Login Without Cookies - Sharing the lti_storage_target Between Platform and Tool",permalink:"/docs/lti/core/poidc-login-lti_storage_target"}},c={},s=[{value:"Overview",id:"overview",level:3},{value:"Sample",id:"sample",level:3}],d=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},u=d("VersioningTracker"),p=d("AuthorBox"),h={toc:s},g="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(g,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(u,{frontMatter:i,mdxType:"VersioningTracker"}),(0,o.kt)("h3",{id:"overview"},"Overview"),(0,o.kt)("p",null,"The Open ID Connect 3rd-party-initiated login is the first step in handling an LTI 1.3 launch."),(0,o.kt)("p",null,"From Learn you will receive a GET request to the URL you registered in the developer portal when you registered your application. The handling of this request is straight forward, but you'll need to note a couple of things."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"You will receive and lti_message_hint as a URL parameter. You must send it back unaltered."),(0,o.kt)("li",{parentName:"ol"},"We do send the client_id and lti_deployment_id on the request, but note they are not required by the specification."),(0,o.kt)("li",{parentName:"ol"},"We strongly recommend you create a ",(0,o.kt)("em",{parentName:"li"},"state")," parameter value and send that with your response, and store that locally so it can be verified on the subsequent launch request. This is how you prevent CSRF attacks. Note, that Safari currently doesn't support sending 3rd party cookies back if you are hosted in an iframe.")),(0,o.kt)("h3",{id:"sample"},"Sample"),(0,o.kt)("p",null,"Some sample code in Node.js is below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'exports.oidcLogin = function(req, res) {\n  const state = uuid.v4(); // save this locally, such as in a cookie; optional in the OIDC spec\n  const nonce = uuid.v4(); // Used to prevent playback\n  const client = // You\'ll need to determine the client ID for this request from parameters on the request\n  const redirectUri = // Get the Redirect URI for this client\n  const oidcAuthUrl = // The URL you were given for this client when you registered your application\n\n  let url =\n    oidcAuthUrl +\n    "?response_type=id_token" +\n    "&scope=openid" +\n    "&login_hint=" +\n    req.query.login_hint +\n    "&lti_message_hint=" +\n    req.query.lti_message_hint +\n    "&state=" +\n    state +\n    "&redirect_uri=" +\n    encodeURIComponent(redirectUri) +\n    "&client_id=" +\n    clientId +\n    "&nonce=" +\n    nonce;\n\n  res.redirect(url);\n};\n')),(0,o.kt)(p,{frontMatter:i,mdxType:"AuthorBox"}))}m.isMDXComponent=!0}}]);